# Лабораторная работа №10

## Цель работы
Сформировать умения разрабатывать, отлаживать и испытывать программы, реализующие механизм наследования.

## Условия заданий

### Задание 1: Реализация базового наследования (1 родительский класс, 2 дочерних)
Создайте классы с наследованием и переопределением методов:

**Вариант 3: Animal, Dog, Cat** ✅
- **Родительский класс**: Animal с полем Name и методом Sound()
- **Дочерние классы**: Dog и Cat, переопределяющие метод Sound()
- **Функциональность**: Демонстрация полиморфизма через виртуальные методы

### Задание 2: Работа с массивами объектов и их обработка
Создайте массивы дочерних классов через родительский класс:

**Вариант 3: Массив Animal, Dog, Cat** ✅
- **Операция**: Фильтрация животных по типу
- **Функциональность**: Создание массива объектов Animal, содержащего Dog и Cat
- **Обработка**: Использование OfType<> для фильтрации по типу

### Задание 3: Сложная логика с бизнес-процессами
Реализуйте систему с наследованием и бизнес-логикой:

**Вариант 3: Система учёта домашних животных** ✅
- **Классы**: Animal, Dog, Cat с наследованием
- **Система**: PetRegistry для управления животными
- **Функциональность**: Добавление животных, подсчёт количества по типам

## Теория

### Основы наследования в C#

**Наследование** - это механизм объектно-ориентированного программирования, позволяющий создавать новые классы на основе существующих, наследуя их свойства и методы.

#### Принципы наследования:
- **Переиспользование кода** - дочерние классы могут использовать код родительского
- **Расширение функциональности** - дочерние классы могут добавлять новые возможности
- **Полиморфизм** - объекты дочерних классов могут использоваться вместо объектов родительского класса

### Синтаксис наследования

```csharp
// Родительский (базовый) класс
public class Animal
{
    public string Name { get; set; }
    
    public Animal(string name)
    {
        Name = name;
    }
    
    // Виртуальный метод для переопределения
    public virtual void Sound()
    {
        Console.WriteLine("Издает звук");
    }
}

// Дочерний класс
public class Dog : Animal
{
    public Dog(string name) : base(name) { }
    
    // Переопределение метода
    public override void Sound()
    {
        Console.WriteLine("Гав-гав!");
    }
}
```

### Ключевые слова наследования

#### `: base()`
Вызов конструктора родительского класса:
```csharp
public class Cat : Animal
{
    public Cat(string name) : base(name) { }
}
```

#### `virtual` и `override`
Позволяют переопределять методы в дочерних классах:
```csharp
// В родительском классе
public virtual void MakeSound() { }

// В дочернем классе
public override void MakeSound() { }
```

#### `new`
Скрытие метода родительского класса (не рекомендуется):
```csharp
public new void MakeSound() { }
```

### Типы наследования

#### Одиночное наследование
C# поддерживает только одиночное наследование классов:
```csharp
public class Dog : Animal { } // Правильно
// public class Dog : Animal, Pet { } // Ошибка!
```

#### Множественное наследование интерфейсов
Класс может реализовывать несколько интерфейсов:
```csharp
public class Dog : Animal, IPet, ITrainable { }
```

### Полиморфизм

#### Полиморфизм времени выполнения
Объекты дочерних классов могут использоваться через ссылки родительского типа:
```csharp
Animal[] animals = new Animal[]
{
    new Dog("Шарик"),
    new Cat("Мурка")
};

foreach (var animal in animals)
{
    animal.Sound(); // Вызовется соответствующий метод
}
```

#### Приведение типов
```csharp
Animal animal = new Dog("Шарик");
Dog dog = (Dog)animal; // Явное приведение
Dog dog2 = animal as Dog; // Безопасное приведение
```

### Абстрактные классы и методы

#### Абстрактный класс
Нельзя создать экземпляр, только наследоваться:
```csharp
public abstract class Animal
{
    public abstract void Sound(); // Абстрактный метод
    public virtual void Sleep() { } // Виртуальный метод
}
```

#### Абстрактный метод
Должен быть реализован в дочерних классах:
```csharp
public class Dog : Animal
{
    public override void Sound() // Обязательная реализация
    {
        Console.WriteLine("Гав!");
    }
}
```

### Интерфейсы

#### Определение интерфейса
```csharp
public interface IPet
{
    void Play();
    string Owner { get; set; }
}
```

#### Реализация интерфейса
```csharp
public class Dog : Animal, IPet
{
    public string Owner { get; set; }
    
    public void Play()
    {
        Console.WriteLine("Играет с мячиком");
    }
}
```

### Модификаторы доступа в наследовании

- **public** - доступен везде
- **protected** - доступен в классе и наследниках
- **private** - доступен только в классе
- **internal** - доступен в сборке

```csharp
public class Animal
{
    protected string name; // Доступно в наследниках
    private int age; // Только в этом классе
}
```

### Конструкторы в наследовании

#### Цепочка конструкторов
```csharp
public class Animal
{
    public Animal(string name) { }
}

public class Dog : Animal
{
    public Dog(string name, string breed) : base(name) { }
}
```

### Методы Object

#### Переопределение базовых методов
```csharp
public class Animal
{
    public override string ToString()
    {
        return $"Animal: {Name}";
    }
    
    public override bool Equals(object obj)
    {
        if (obj is Animal other)
            return Name == other.Name;
        return false;
    }
    
    public override int GetHashCode()
    {
        return Name.GetHashCode();
    }
}
```

### Практические рекомендации

#### Дизайн наследования:
1. **"Является" отношение** - Dog является Animal
2. **Избегайте глубокого наследования** - не более 3-4 уровней
3. **Используйте композицию вместо наследования** когда возможно
4. **Следуйте принципу LSP** (Liskov Substitution Principle)

#### Выбор между наследованием и интерфейсами:
- **Наследование** - для "является" отношений с общей реализацией
- **Интерфейсы** - для "может" отношений и множественного наследования

#### Производительность:
- Виртуальные методы имеют небольшие накладные расходы
- Используйте `sealed` для классов, которые не будут наследоваться
- Рассматривайте `struct` для простых типов данных

### Паттерны проектирования с наследованием

#### Шаблонный метод
```csharp
public abstract class Animal
{
    public void DailyRoutine()
    {
        WakeUp();
        Eat();
        Play();
        Sleep();
    }
    
    protected abstract void Play();
    protected virtual void Eat() { }
    protected virtual void Sleep() { }
    private void WakeUp() { }
}
```

#### Стратегия
```csharp
public interface ISoundStrategy
{
    void MakeSound();
}

public class Dog : Animal
{
    private ISoundStrategy soundStrategy;
    
    public void SetSoundStrategy(ISoundStrategy strategy)
    {
        soundStrategy = strategy;
    }
}
```

### Отладка наследования

#### Полезные методы:
- `GetType()` - получение точного типа объекта
- `is` - проверка типа
- `as` - безопасное приведение типа
- `typeof()` - получение типа на этапе компиляции

```csharp
Animal animal = new Dog("Шарик");
Console.WriteLine(animal.GetType().Name); // "Dog"
Console.WriteLine(animal is Dog); // true
Console.WriteLine(animal is Animal); // true
```

Эта теория охватывает все основные концепции наследования, которые были применены в выполненных заданиях лабораторной работы №10. 