# Лабораторная работа №14: Наследование интерфейсов

## Цель работы
Сформировать умения разрабатывать, отлаживать и испытывать программы с использованием механизма наследования интерфейсов.

## Выполненные задания (3-й вариант)

### Задание 1: Создание трёх интерфейсов
**Вариант 3: Обработка текстов**
- Описаны три интерфейса: `IWordSearch` (поиск слов), `IWordReplace` (замена слов), `ITextAnalyzer` (наследует оба, содержит свойство Text).

### Задание 2: Реализация интерфейса Наследника
**Вариант 3: Текстовый анализатор**
- Класс `TextAnalyzer` реализует интерфейс-наследник `ITextAnalyzer`. Реализованы методы поиска и замены слов, свойство текста.

### Задание 3: Работа с массивом объектов, фильтрация и сортировка
**Вариант 3: Текстовый файл**
- Класс `TextFile` реализует только интерфейс поиска слов. Создан массив объектов `TextAnalyzer` и `TextFile`, реализованы фильтрация по количеству слов и сортировка.

---

## Теоретические основы

### Наследование интерфейсов

**Определение:** Интерфейс может наследовать один или несколько других интерфейсов, объединяя их контракты.

**Особенности:**
- Интерфейс-наследник обязан реализовать все члены базовых интерфейсов
- Класс, реализующий интерфейс-наследник, реализует все методы всех базовых интерфейсов
- Позволяет строить сложные иерархии поведения

**Синтаксис:**
```csharp
public interface IBase1 { void M1(); }
public interface IBase2 { void M2(); }
public interface IDerived : IBase1, IBase2 { void M3(); }
```

### Пример использования
```csharp
public interface IWordSearch { List<string> SearchWords(string s); }
public interface IWordReplace { string ReplaceWord(string oldW, string newW); }
public interface ITextAnalyzer : IWordSearch, IWordReplace { string Text { get; set; } }

public class TextAnalyzer : ITextAnalyzer
{
    public string Text { get; set; }
    public List<string> SearchWords(string s) { ... }
    public string ReplaceWord(string oldW, string newW) { ... }
}
```

### Преимущества наследования интерфейсов
- **Множественное наследование:** интерфейс может наследовать несколько интерфейсов
- **Гибкость:** можно комбинировать поведение
- **Полиморфизм:** объекты можно использовать через любой из базовых интерфейсов
- **Расширяемость:** легко добавлять новые интерфейсы и реализации

### Практические рекомендации
- Используйте наследование интерфейсов для объединения логически связанных контрактов
- Не добавляйте реализацию в интерфейс (до C# 8.0)
- Следуйте соглашениям об именовании
- Документируйте интерфейсы XML-комментариями

### Примеры из .NET
- `ICollection<T>` : `IEnumerable<T>`, `IEnumerable`
- `IDictionary<TKey, TValue>` : `ICollection<KeyValuePair<TKey, TValue>>`, `IEnumerable<KeyValuePair<TKey, TValue>>`

### LINQ и интерфейсы
- Используйте интерфейсы для фильтрации, сортировки, поиска в коллекциях

### Отладка и тестирование
- Используйте интерфейсы для внедрения зависимостей (DI)
- Легко подменять реализации для юнит-тестов

---

**Лабораторная работа выполнена с акцентом на компактность, читаемость и демонстрацию наследования интерфейсов в C#.** 