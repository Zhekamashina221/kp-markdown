# Лабораторная работа №16: Делегаты

## Цель работы
Сформировать умения разрабатывать, отлаживать и использовать делегаты в программах.

## Выполненные задания (3-й вариант)

### Задание 1: Создание пользовательского делегата и вызов методов через него
**Вариант 3: Вывод квадрата и куба числа**

- Создан пользовательский делегат `NumberOperation` для работы с числами.
- Класс `NumberProcessor` содержит методы `PrintSquare` и `PrintCube`.
- Демонстрируется создание делегата, привязка методов и вызов через делегат.

### Задание 2: Работа с анонимными делегатами
**Вариант 3: Проверка четности числа**

- Использованы анонимные делегаты `Func<int, bool>` для проверки четности.
- Реализованы делегаты для подсчета четных чисел и фильтрации массива.
- Демонстрируется работа с анонимными делегатами и лямбда-выражениями.

### Задание 3: Использование стандартных делегатов для реализации колбэка
**Вариант 3: Обработка массива строк с Action<string>**

- Метод `ProcessStringArray` принимает массив строк и делегат `Action<string>`.
- Реализованы различные методы-колбэки для обработки строк.
- Демонстрируется использование лямбда-выражений в качестве колбэков.

---

## Теоретические основы

### Делегаты в C#

**Определение:** Делегат - это тип, представляющий ссылку на метод с определенной сигнатурой.

**Особенности делегатов:**
- Типобезопасные указатели на функции
- Поддерживают multicast (множественные вызовы)
- Могут быть анонимными
- Используются для событий и колбэков

**Синтаксис:**
```csharp
public delegate void MyDelegate(string message);
public delegate int CalculateDelegate(int x, int y);
```

### Пользовательские делегаты

**Создание:**
```csharp
public delegate void NumberOperation(int number);

public class Calculator
{
    public void Add(int x, int y) => Console.WriteLine(x + y);
    public void Subtract(int x, int y) => Console.WriteLine(x - y);
}

// Использование
var calc = new Calculator();
NumberOperation op = calc.Add;
op += calc.Subtract;
op(5, 3);
```

### Анонимные делегаты

**Синтаксис:**
```csharp
Func<int, bool> isEven = delegate(int number)
{
    return number % 2 == 0;
};

// Лямбда-выражения (современный синтаксис)
Func<int, bool> isEvenLambda = number => number % 2 == 0;
```

### Стандартные делегаты

**Action<T>** - делегат без возвращаемого значения:
```csharp
Action<string> printAction = message => Console.WriteLine(message);
Action<int, int> addAction = (x, y) => Console.WriteLine(x + y);
```

**Func<T, TResult>** - делегат с возвращаемым значением:
```csharp
Func<int, int> square = x => x * x;
Func<int, int, int> add = (x, y) => x + y;
```

**Predicate<T>** - делегат, возвращающий bool:
```csharp
Predicate<int> isPositive = x => x > 0;
```

### Использование делегатов

**Колбэки:**
```csharp
public void ProcessData(int[] data, Action<int> callback)
{
    foreach (int item in data)
    {
        callback(item);
    }
}

// Использование
ProcessData(numbers, x => Console.WriteLine(x));
```

**События:**
```csharp
public event Action<string> DataProcessed;

protected virtual void OnDataProcessed(string result)
{
    DataProcessed?.Invoke(result);
}
```

### Лямбда-выражения

**Синтаксис:**
```csharp
// Одно выражение
Func<int, int> square = x => x * x;

// Несколько выражений
Func<int, int> complex = x => 
{
    int result = x * x;
    Console.WriteLine($"Квадрат {x} = {result}");
    return result;
};
```

### Multicast делегаты

**Особенности:**
- Делегат может содержать несколько методов
- Методы вызываются в порядке добавления
- Возвращаемое значение только от последнего метода

```csharp
Action<string> multiAction = s => Console.WriteLine($"1: {s}");
multiAction += s => Console.WriteLine($"2: {s}");
multiAction += s => Console.WriteLine($"3: {s}");

multiAction("test"); // Выведет все три сообщения
```

### Практические применения

**LINQ:**
```csharp
var evenNumbers = numbers.Where(x => x % 2 == 0);
var doubled = numbers.Select(x => x * 2);
```

**Сортировка:**
```csharp
Array.Sort(strings, (a, b) => a.Length.CompareTo(b.Length));
```

**Фильтрация:**
```csharp
var filtered = items.Where(item => item.IsActive);
```

### Отладка делегатов

**Советы:**
- Используйте точки останова в методах делегатов
- Проверяйте null перед вызовом
- Логируйте вызовы делегатов
- Используйте GetInvocationList() для отладки multicast делегатов

### Производительность

**Рекомендации:**
- Кэшируйте делегаты для повторного использования
- Избегайте создания делегатов в циклах
- Используйте статические методы где возможно
- Рассмотрите использование struct делегатов для производительности

### Примеры использования

**Обработка событий:**
```csharp
public class DataProcessor
{
    public event Action<string> ProcessingStarted;
    public event Action<string> ProcessingCompleted;
    
    public void Process(string data)
    {
        ProcessingStarted?.Invoke(data);
        // Обработка данных
        ProcessingCompleted?.Invoke("Готово");
    }
}
```

**Конфигурируемые алгоритмы:**
```csharp
public class Sorter
{
    public void Sort<T>(T[] array, Func<T, T, int> comparer)
    {
        Array.Sort(array, new Comparison<T>(comparer));
    }
}
```

---

**Лабораторная работа выполнена с акцентом на компактность, читаемость и демонстрацию использования делегатов в C#.** 