# Лабораторная работа №18: События

## Теория

### События (Events)

События - это механизм, позволяющий объектам уведомлять другие объекты о происходящих изменениях. Они реализуют паттерн "Наблюдатель" (Observer) и обеспечивают слабую связанность между компонентами.

#### Основные концепции

1. **Издатель (Publisher)** - объект, который генерирует события
2. **Подписчик (Subscriber)** - объект, который обрабатывает события
3. **Делегат события** - определяет сигнатуру метода обработчика
4. **Аргументы события** - данные, передаваемые с событием

#### Синтаксис событий

```csharp
// Объявление события
public event EventHandler<CustomEventArgs> MyEvent;

// Вызов события
protected virtual void OnMyEvent(CustomEventArgs e)
{
    MyEvent?.Invoke(this, e);
}

// Подписка на событие
publisher.MyEvent += OnMyEvent;

// Отписка от события
publisher.MyEvent -= OnMyEvent;
```

#### Стандартные делегаты событий

```csharp
// EventHandler - без дополнительных данных
public event EventHandler SimpleEvent;

// EventHandler<T> - с типизированными аргументами
public event EventHandler<CustomEventArgs> TypedEvent;

// Пользовательский делегат
public delegate void CustomEventHandler(object sender, CustomEventArgs e);
public event CustomEventHandler CustomEvent;
```

#### Аргументы событий

```csharp
public class CustomEventArgs : EventArgs
{
    public string Message { get; set; }
    public DateTime Timestamp { get; set; }
    
    public CustomEventArgs(string message)
    {
        Message = message;
        Timestamp = DateTime.Now;
    }
}
```

### Стандартные события Console

#### Console.CancelKeyPress
```csharp
Console.CancelKeyPress += (sender, e) =>
{
    Console.WriteLine("Программа завершается...");
    e.Cancel = true; // Отмена завершения
};
```

#### Console.KeyAvailable
```csharp
while (!Console.KeyAvailable)
{
    // Ожидание нажатия клавиши
    Thread.Sleep(100);
}
```

#### Console.TreatControlCAsInput
```csharp
Console.TreatControlCAsInput = true; // Ctrl+C как обычный ввод
```

### Паттерн "Наблюдатель"

#### Структура
```csharp
// Интерфейс наблюдателя
public interface IObserver
{
    void Update(string message);
}

// Интерфейс субъекта
public interface ISubject
{
    void Attach(IObserver observer);
    void Detach(IObserver observer);
    void Notify(string message);
}

// Реализация субъекта
public class Subject : ISubject
{
    private List<IObserver> observers = new List<IObserver>();
    
    public void Attach(IObserver observer)
    {
        observers.Add(observer);
    }
    
    public void Detach(IObserver observer)
    {
        observers.Remove(observer);
    }
    
    public void Notify(string message)
    {
        foreach (var observer in observers)
        {
            observer.Update(message);
        }
    }
}
```

### Лучшие практики

#### 1. Безопасность потоков
```csharp
protected virtual void OnMyEvent(CustomEventArgs e)
{
    // Создание копии для безопасности потоков
    var handler = MyEvent;
    handler?.Invoke(this, e);
}
```

#### 2. Проверка на null
```csharp
// Всегда проверяйте на null перед вызовом
MyEvent?.Invoke(this, e);
```

#### 3. Правильная отписка
```csharp
public void Dispose()
{
    // Отписка от событий при уничтожении объекта
    publisher.MyEvent -= OnMyEvent;
}
```

#### 4. Использование виртуальных методов
```csharp
protected virtual void OnMyEvent(CustomEventArgs e)
{
    MyEvent?.Invoke(this, e);
}
```

### Примеры использования

#### Система уведомлений
```csharp
public class NotificationService
{
    public event EventHandler<NotificationEventArgs> NotificationSent;
    
    public void SendNotification(string message, string recipient)
    {
        var args = new NotificationEventArgs(message, recipient);
        OnNotificationSent(args);
    }
    
    protected virtual void OnNotificationSent(NotificationEventArgs e)
    {
        NotificationSent?.Invoke(this, e);
    }
}
```

#### Обработка пользовательского ввода
```csharp
public class InputHandler
{
    public event EventHandler<KeyPressEventArgs> KeyPressed;
    
    public void ProcessInput()
    {
        var key = Console.ReadKey();
        var args = new KeyPressEventArgs(key);
        OnKeyPressed(args);
    }
}
```

#### Система логирования
```csharp
public class Logger
{
    public event EventHandler<LogEventArgs> LogEntryAdded;
    
    public void Log(string message, LogLevel level)
    {
        var args = new LogEventArgs(message, level);
        OnLogEntryAdded(args);
    }
}
```

### Преимущества событий

1. **Слабая связанность** - компоненты не зависят друг от друга
2. **Расширяемость** - легко добавлять новые обработчики
3. **Переиспользование** - один издатель может иметь много подписчиков
4. **Тестируемость** - легко тестировать компоненты по отдельности
5. **Гибкость** - динамическое подключение/отключение обработчиков

### Недостатки

1. **Сложность отладки** - сложно отследить цепочку вызовов
2. **Утечки памяти** - забытая отписка может привести к утечкам
3. **Порядок выполнения** - не гарантирован порядок обработчиков
4. **Производительность** - накладные расходы на вызов событий

### Типичные сценарии использования

#### UI события
```csharp
button.Click += OnButtonClick;
textBox.TextChanged += OnTextChanged;
```

#### Системные события
```csharp
AppDomain.CurrentDomain.ProcessExit += OnProcessExit;
```

#### События данных
```csharp
database.RecordInserted += OnRecordInserted;
```

#### События бизнес-логики
```csharp
orderService.OrderCreated += OnOrderCreated;
```

## Заключение

События являются мощным механизмом для реализации слабосвязанной архитектуры в C#. Они позволяют создавать гибкие и расширяемые системы, где компоненты могут взаимодействовать без прямых зависимостей. Правильное использование событий значительно улучшает архитектуру приложений и упрощает их поддержку. 