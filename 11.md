# Лабораторная работа №11

## Цель работы
Сформировать умения разрабатывать, отлаживать и испытывать программы, реализующие отношения между классами.

## Условия заданий

### Задание 1: Реализация частичных классов
Разделите функциональность классов на несколько файлов:

**Вариант 3: Частичный класс Product** ✅
- **Файл 1**: Product.cs - свойства (Name, Price, Quantity, Category, Description)
- **Файл 2**: ProductMethods.cs - методы для работы с ценой и количеством
- **Функциональность**: Управление ценой (установка, скидки), управление количеством (добавление, удаление), расчёты и отображение информации

### Задание 2: Реализация взаимодействий между классами
Добавьте взаимодействия между классами:

**Вариант 4: Product и Category** ✅
- **Классы**: Product и Category
- **Взаимодействие**: Каждый Product может принадлежать к Category
- **Функциональность**: Добавление/удаление товаров из категорий, поиск по ценовому диапазону, статистика

### Задание 3: Сложные задачи с бизнес-логикой
Реализуйте систему с дополнительной бизнес-логикой:

**Вариант 6: Складская система** ✅
- **Классы**: Product и Warehouse
- **Бизнес-логика**: Поиск товаров с минимальными остатками, фильтрация по категории, сортировка по сроку годности
- **Функциональность**: Управление товарами, анализ запасов, рекомендации для менеджера

## Теория

### Частичные классы (Partial Classes)

**Частичные классы** - это возможность разделить определение класса на несколько файлов, что позволяет лучше организовать код и работать над разными частями класса параллельно.

#### Синтаксис частичных классов

```csharp
// Файл 1: Product.cs
public partial class Product
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    public int Quantity { get; set; }
}

// Файл 2: ProductMethods.cs
public partial class Product
{
    public void SetPrice(decimal newPrice) { }
    public void AddQuantity(int amount) { }
}
```

#### Преимущества частичных классов:
- **Организация кода** - логическое разделение функциональности
- **Параллельная разработка** - разные разработчики могут работать над разными частями
- **Автогенерация кода** - одна часть может генерироваться автоматически
- **Читаемость** - большие классы становятся более управляемыми

### Отношения между классами

#### Ассоциация (Association)
Самый слабый тип связи - классы знают друг о друге, но не зависят друг от друга.

```csharp
public class Product
{
    public string Name { get; set; }
    public Category Category { get; set; } // Ассоциация
}

public class Category
{
    public string Name { get; set; }
    public List<Product> Products { get; set; } // Ассоциация
}
```

#### Агрегация (Aggregation)
Отношение "часть-целое", где части могут существовать независимо от целого.

```csharp
public class Warehouse
{
    public List<Product> Products { get; set; } // Агрегация
    
    public void AddProduct(Product product)
    {
        Products.Add(product); // Продукт может существовать без склада
    }
}
```

#### Композиция (Composition)
Сильная форма агрегации, где части не могут существовать без целого.

```csharp
public class Order
{
    private List<OrderItem> items = new(); // Композиция
    
    public void AddItem(Product product, int quantity)
    {
        var item = new OrderItem(product, quantity); // Создается внутри заказа
        items.Add(item);
    }
}
```

### Типы отношений

#### Один к одному (1:1)
```csharp
public class Person
{
    public Passport Passport { get; set; }
}

public class Passport
{
    public Person Owner { get; set; }
}
```

#### Один ко многим (1:N)
```csharp
public class Category
{
    public List<Product> Products { get; set; } // Одна категория - много продуктов
}

public class Product
{
    public Category Category { get; set; } // Один продукт - одна категория
}
```

#### Многие ко многим (N:N)
```csharp
public class Student
{
    public List<Course> Courses { get; set; }
}

public class Course
{
    public List<Student> Students { get; set; }
}
```

### Паттерны проектирования для отношений

#### Паттерн Repository
```csharp
public interface IProductRepository
{
    IEnumerable<Product> GetAll();
    Product GetById(int id);
    void Add(Product product);
    void Update(Product product);
    void Delete(int id);
}

public class ProductRepository : IProductRepository
{
    private List<Product> products = new();
    
    public IEnumerable<Product> GetAll() => products;
    public Product GetById(int id) => products.FirstOrDefault(p => p.Id == id);
    public void Add(Product product) => products.Add(product);
    public void Update(Product product) { /* логика обновления */ }
    public void Delete(int id) { /* логика удаления */ }
}
```

#### Паттерн Unit of Work
```csharp
public interface IUnitOfWork
{
    IProductRepository Products { get; }
    ICategoryRepository Categories { get; }
    void SaveChanges();
}

public class UnitOfWork : IUnitOfWork
{
    public IProductRepository Products { get; }
    public ICategoryRepository Categories { get; }
    
    public void SaveChanges()
    {
        // Сохранение всех изменений
    }
}
```

### Управление зависимостями

#### Внедрение зависимостей (Dependency Injection)
```csharp
public class ProductService
{
    private readonly IProductRepository _repository;
    
    public ProductService(IProductRepository repository) // Внедрение зависимости
    {
        _repository = repository;
    }
    
    public IEnumerable<Product> GetLowStockProducts()
    {
        return _repository.GetAll().Where(p => p.Quantity <= 5);
    }
}
```

#### Фабричный метод
```csharp
public class ProductFactory
{
    public static Product CreateProduct(string name, decimal price, string category)
    {
        return new Product
        {
            Name = name,
            Price = price,
            Category = category,
            Quantity = 0
        };
    }
}
```

### LINQ для работы с отношениями

#### Join
```csharp
var productCategories = products.Join(
    categories,
    product => product.CategoryId,
    category => category.Id,
    (product, category) => new { product.Name, category.Name }
);
```

#### GroupBy
```csharp
var productsByCategory = products.GroupBy(p => p.Category)
    .Select(g => new { Category = g.Key, Count = g.Count() });
```

#### Where с условиями
```csharp
var expensiveProducts = products.Where(p => p.Price > 1000);
var lowStockProducts = products.Where(p => p.Quantity <= 5);
```

### События и делегаты для отношений

#### События
```csharp
public class Product
{
    public event EventHandler<ProductEventArgs> PriceChanged;
    
    private decimal _price;
    public decimal Price
    {
        get => _price;
        set
        {
            if (_price != value)
            {
                _price = value;
                PriceChanged?.Invoke(this, new ProductEventArgs(this));
            }
        }
    }
}
```

#### Делегаты
```csharp
public delegate void ProductAction(Product product);

public class Warehouse
{
    public ProductAction OnProductAdded { get; set; }
    
    public void AddProduct(Product product)
    {
        Products.Add(product);
        OnProductAdded?.Invoke(product);
    }
}
```

### Сериализация отношений

#### JSON сериализация
```csharp
public class Product
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    [JsonIgnore] // Исключить из сериализации
    public Category Category { get; set; }
    public int CategoryId { get; set; } // Для сериализации
}
```

#### XML сериализация
```csharp
[XmlRoot("Product")]
public class Product
{
    [XmlElement("Name")]
    public string Name { get; set; }
    
    [XmlElement("Price")]
    public decimal Price { get; set; }
}
```

### Практические рекомендации

#### Дизайн отношений:
1. **Минимизируйте связанность** - используйте слабые связи
2. **Следуйте принципу единственной ответственности**
3. **Используйте интерфейсы** для слабой связанности
4. **Избегайте циклических зависимостей**

#### Производительность:
1. **Ленивая загрузка** для больших коллекций
2. **Кэширование** часто используемых данных
3. **Пагинация** для больших наборов данных
4. **Индексы** для быстрого поиска

#### Безопасность:
1. **Валидация данных** на всех уровнях
2. **Проверка прав доступа**
3. **Логирование** важных операций
4. **Обработка исключений**

### Отладка отношений

#### Полезные методы:
```csharp
// Проверка на null
if (product?.Category != null) { }

// Безопасное приведение типов
if (obj is Product product) { }

// Проверка существования
if (products.Any(p => p.Category == category)) { }

// Отладка циклических ссылок
[JsonIgnore]
public Category Category { get; set; }
```

Эта теория охватывает все основные концепции отношений между классами, которые были применены в выполненных заданиях лабораторной работы №11. 