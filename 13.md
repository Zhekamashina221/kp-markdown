# Лабораторная работа №13: Интерфейсы

## Цель работы
Разработка, отладка и испытание программ с применением интерфейсов.

## Выполненные задания (3-й вариант)

### Задание 1: Создание/описание интерфейса
**Вариант 3: Обработка текстовых данных**

- Описаны интерфейсы для обработки текста (`ITextProcessor`), работы с файлами (`IFileOperations`) и статистики текста (`ITextStatistics`).

### Задание 2: Реализация интерфейса в классе
**Вариант 3: Текстовый файл**

- Класс `TextFile` реализует интерфейсы обработки текста, работы с файлами и статистики текста. Демонстрируется работа с текстом, поиск, статистика, полиморфизм.

### Задание 3: Массив элементов интерфейса, сортировка, поиск, фильтрация
**Вариант 3: Бинарный файл**

- Класс `BinaryFile` реализует интерфейсы обработки текстовых данных и работы с файлами. Создается массив файлов (текстовых и бинарных), реализованы сортировка по размеру, фильтрация по размеру, вывод информации.

### Задание 4: Явная реализация методов интерфейсов
**Вариант 3: IEquatable в Банковский счет**

- Класс `BankAccount` реализует интерфейс `IBankAccount` и явную реализацию `IEquatable<BankAccount>`. Сравнение счетов по номеру, демонстрация работы с интерфейсом.

---

## Теоретические основы

### Интерфейсы в C#

**Определение:** Интерфейс — это контракт, определяющий набор методов и свойств, которые должен реализовать класс.

**Особенности интерфейсов:**
- Не содержат реализацию (только сигнатуры)
- Не могут содержать поля
- Класс может реализовывать несколько интерфейсов
- Интерфейсы поддерживают множественное наследование
- Интерфейсы могут наследовать другие интерфейсы

**Синтаксис:**
```csharp
public interface IShape
{
    double GetArea();
    double GetPerimeter();
}
```

**Реализация интерфейса:**
```csharp
public class Circle : IShape
{
    public double Radius { get; set; }
    public double GetArea() => Math.PI * Radius * Radius;
    public double GetPerimeter() => 2 * Math.PI * Radius;
}
```

### Явная реализация интерфейса

**Когда используется:**
- Когда требуется скрыть реализацию метода интерфейса
- Когда методы интерфейсов совпадают по сигнатуре

**Пример:**
```csharp
public interface IPrintable { void Print(); }
public interface IScannable { void Print(); }

public class Device : IPrintable, IScannable
{
    void IPrintable.Print() => Console.WriteLine("Печать");
    void IScannable.Print() => Console.WriteLine("Сканирование");
}
```

### Преимущества использования интерфейсов
1. **Абстракция:** Сокрытие деталей реализации
2. **Полиморфизм:** Разные классы могут реализовывать один интерфейс
3. **Гибкость:** Класс может реализовывать несколько интерфейсов
4. **Тестируемость:** Легко создавать моки для тестирования
5. **Слабая связанность:** Классы зависят от интерфейсов, а не от конкретных реализаций

### Практические рекомендации
- Используйте интерфейсы для описания поведения
- Не добавляйте реализацию в интерфейс (до C# 8.0)
- Используйте явную реализацию для устранения конфликтов
- Следуйте соглашениям об именовании (IShape, IAccount)
- Документируйте интерфейсы XML-комментариями

### Интерфейсы .NET
- `IComparable`, `IEquatable`, `IEnumerable`, `IDisposable`, `ICloneable`, `IFormattable`, `IComparer`, `IConvertible` и др.
- Используйте стандартные интерфейсы для интеграции с .NET API

### Примеры использования в реальных проектах
- Репозитории данных (`IRepository<T>`)
- Сервисы (`IService`, `ILogger`)
- Плагины и расширения
- Тестовые двойники (Mock, Stub)

### LINQ и интерфейсы
- Интерфейсы коллекций (`IEnumerable<T>`, `IQueryable<T>`) позволяют использовать LINQ для фильтрации, сортировки, поиска

### Отладка и тестирование
- Используйте интерфейсы для внедрения зависимостей (Dependency Injection)
- Легко подменять реализации для юнит-тестов

---

**Лабораторная работа выполнена с акцентом на компактность, читаемость и демонстрацию ключевых концепций интерфейсов в C#.** 